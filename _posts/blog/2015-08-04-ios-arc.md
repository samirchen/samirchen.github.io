---
layout: post
title: iOS 在 ARC 特性下的内存管理要点
description: 总结 iOS 在 ARC 特性下的内存管理技术。
category: blog
tag: iOS, ARC
---
##前言
ARC 是编译器（时）特性，而不是运行时特性，更不是垃圾回收器(GC)。

>Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications.

ARC 特性下有几种修饰符需要我们关注：

- `__strong`
- `__weak`
- `__autoreleasing`
- `__unsafe_unretaied`

##关于 \_\_strong
`__strong` 表示强引用，对应定义 property 时用到的 `strong`。当对象没有任何一个强引用指向它时，它才会被释放。如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，可以将强引用置为 nil 来做到。

##关于 \_\_weak
`__weak` 表示弱引用，对应定义 property 时用到的 `weak`。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 nil，这样可以防止野指针。

\_\_weak 的几个应用场景：

- 用在 Delegate 关系中防止强引用循环。
- 用在 Block 中防止强引用循环。
- 用来修饰指向 Interface Builder 编辑与生成的控件。比如：`@property (weak, nonatomic) IBOutlet UIButton *testButton;`。



##关于 \_\_autoreleasing
`__autoreleasing` 表示自动释放的引用，它修饰的对象会在 Autorelease Pool 中自动释放，和 MRC 时代的 autorelease 的用法相同。定义 property 时不能使用这个修饰符，因为任何一个对象的 property 都不应该是 autorelease 类型的。

\_\_autoreleasing 是使用场景：

- 参数传递返回值。
- 引用传递参数(pass-by-reference(id *))。

###参数传递返回值
在方法中返回参数来传递返回值的时候，应用程序一般会做类似下面的一系列动作：

- 1）从队列中获取下一个消息；
- 2）创建一个 Autorelease Pool；
- 3）调用即将被返回的对象的 autorelease 方法，将对象添加到 Autorelease Pool 中；
- 4）分发消息，这个时候，对象被传递出去，如果你需要用它，就会在这里 retain 它，在 ARC 下即强引用持有它。
- 5）销毁 Autorelease Pool，这时所有在这个 Autorelease Pool 中的对象都会被调用 release 方法（要理解 release 的含义只是将对象的引用计数减 1）。这时，由于你在第 4 步中强引用持有了对象，所以你拿着它是可以放心的继续使用的，而它的引用计数也是对的，你用完了释放掉对象，对象就销毁了。


###引用传递参数
看一个最常见的例子：

	NSError *__autoreleasing error; 
	￼if (![data writeToFile:filename options:NSDataWritingAtomic error:&error]) { 
	　　NSLog(@"Error: %@", error); 
	}
	
	// 即使上面你没有写 __autoreleasing 来修饰 error，编译器也会帮你做下面的事情：
	NSError *error; 
	NSError *__autoreleasing tempError = error; // 编译器添加 
	if (![data writeToFile:filename options:NSDataWritingAtomic error:&tempError]) 
	￼{ 
	　　error = tempError; // 编译器添加 
	　　NSLog(@"Error: %@", error); 
	}

error 对象在你调用的方法中被创建，然后被放到 Autorelease Pool 中，等到使用结束后随着 Autorelease Pool 的销毁而释放，所以函数外 error 对象的使用者不需要关心它的释放。

在 ARC 中，所有这种指针的指针类型（NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为 `__autoreleasing` 类型。


有一点特别需要注意的是，某些类的方法会隐式地使用自己的 Autorelease Pool，在这种时候使用 `__autoreleasing` 类型要特别小心。比如 NSDictionary 的 enumerateKeysAndObjectsUsingBlock 方法：

	- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error {
	    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
	
	          // do stuff  
	          if (there is some error && error != nil) {
	                *error = [NSError errorWithDomain:@"MyError" ￼code:1 userInfo:nil];
	          }
	￼
	    }];
	￼}
	
上面的代码中其实会隐式地创建一个 Autorelease Pool，类似于：

	- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error {
	    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
	
	          @autoreleasepool {  // 被隐式创建。
	              if (there is some error && error != nil) {
	                    *error = [NSError errorWithDomain:@"MyError" ￼code:1 userInfo:nil];
	              }
	￼          }
	    }];
	
	    // *error 在这里已经被dict的做枚举遍历时创建的 Autorelease Pool释放掉了。
	￼} 

为了能够正常的使用 *error，我们需要一个 strong 类型的临时引用，在 dict 的枚举 Block 中是用这个临时引用，保证引用指向的对象不会在出了 dict 的枚举 Block 后被释放，正确的方式如下：

	- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error {
	　　NSError * __block tempError; // 加 __block 保证可以在Block内被修改。
	　　[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) { 
	　　　　if (there is some error) { 
	　　　　　　*tempError = [NSError errorWithDomain:@"MyError" ￼code:1 userInfo:nil]; 
	　　　　} ￼ 
	
	　　}] 
	
	　　if (error != nil) { 
	　　　　*error = tempError; 
	　　} ￼
	}
	


##关于 \_\_unsafe_unretained

ARC 是在 iOS 5 引入的，而 `__unsafe_unretained` 这个修饰符主要是为了在 ARC 刚发布时兼容 iOS 4 以及版本更低的设备，因为这些版本的设备没有 weak pointer system，简单的理解这个系统就是我们上面讲 weak 时提到的，能够在 weak 引用指向对象被释放后，把引用值自动设为 nil 的系统。这个修饰符在定义 property 时对应的是 `unsafe_unretained`，实际可以将它理解为 MRC 时代的 assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然原原本本地指向原来被释放的对象（所在的内存区域）。所以非常不安全。

\_\_unsafe_unretained 的应用场景：

- 在 ARC 环境下但是要兼容 iOS 4.x 的版本，用 `__unsafe_unretained` 替代 `__weak` 解决强引用循环的问题。

参考：

- [Transitioning to ARC Release Notes](https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html)
- [iOS开发ARC内存管理技术要点](http://www.cnblogs.com/flyFreeZn/p/4264220.html)


[SamirChen]: http://samirchen.com "SamirChen"
[1]: {{ page.url }} ({{ page.title }})
[2]: http://samirchen.com/ios-arc/
